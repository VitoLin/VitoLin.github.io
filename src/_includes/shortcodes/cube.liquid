<div id="scene-container" style="width:100%; height:400px;"></div>

<script type="module">
    import * as THREE from '/js/three.module.min.js';
    import { animate } from '/js/anime.esm.min.js';

    const container = document.getElementById('scene-container');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshNormalMaterial());
    scene.add(cube);

    // Create an anime.js animation but do not autoplay â€” we'll control progress via scroll.
    const rotationAnim = animate(
        cube.rotation,
        {
            x: Math.PI * 2,
            y: Math.PI * 2,
            duration: 4000,
            easing: 'easeInOutSine',
            autoplay: false,
        }
    );

    // number of full rotations across the entire page scroll (use 1 for one full loop)
    const loops = 1;

    // throttle scroll updates using rAF
    let ticking = false;
    let containerVisible = true;

    function updateAnimationFromScroll() {
        const doc = document.documentElement;
        const scrollTop = window.scrollY || doc.scrollTop;
        const maxScroll = doc.scrollHeight - window.innerHeight;
        const progress = maxScroll > 0 ? scrollTop / maxScroll : 0;

        // If you want N full rotations across the page, map progress * loops into the animation timeline.
        // Using % 1 keeps it within one animation duration while allowing multiple loops.
        const loopedProgress = (progress * loops) % 1;
        rotationAnim.seek(rotationAnim.duration * loopedProgress);
    }

    // requestAnimationFrame throttle wrapper
    function onScroll() {
        if (!ticking && containerVisible) {
            ticking = true;
            requestAnimationFrame(() => {
                updateAnimationFromScroll();
                ticking = false;
            });
        }
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    onScroll(); // init to current scroll position

    // Resize handling
    function onResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }
    window.addEventListener('resize', onResize, { passive: true });
    onResize();

    // Optional: only update when the container is visible
    const io = new IntersectionObserver((entries) => {
        containerVisible = entries[0].isIntersecting;
        if (containerVisible) onScroll();
    }, { threshold: 0 });
    io.observe(container);

    // Keep the render loop for Three.js rendering.
    function render() {
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }
    render();
</script>
